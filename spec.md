# Table Of Contents

	## Overview

	1. Preprocessor

		a. Comments
		b. Includes
		c. Macros
		d. Conditionals
		e. Escape Codes
		f. Line Continuation

	2. Syntax

		a. Overview
		b. Keywords
		c. Declarations
		d. Assignments
		e. Functions
		f. Expressions
		g. Classes
		h. Inheritance
		i. Identifiers

	3. Standard Library

		a. Base Classes

# Overview

The language defined in this specification utilizes a simple syntax. The syntax is not alike the syntax of C family languages, it is more along the lines of Python. A single line represents a single operation. Indentation matters and is strictly enforced by the compiler. Bear in mind that as this language is compileable, the variables and functions are strictly typed (a variable is assigned a type on creation which may not ever change). This will hopefully give you a basic idea of the language that is represented hereon.

# Preprocessor

The preprocessor is responsible for processing raw text input and preparing it for the next stages in the compiler. The preprocessor will handle the removal of comments, the inclusion of header files, the definition, replacement and undefinition of macros, along with conditionals and ANSI escape code formatting.

	1. Comments

  Comments are lines that do not serve any computational purpose; they are used only for providing information to the programmer. Comments can be found by checking if the first character of a line (if any) is a hashtag symbol ('#'). If so, the line may be discarded.

	Comments may also exist alongside a functional line of code. Whenever a hashtag symbol is encountered outside of a string or character literal, then that character and any that follow it must be discarded by the preprocessor.
 ```c
int n = 1;  // This variable is of no significance whatsoever, to mortals and immortals alike.
//becomes
int n = 1;
 ```
  2. Includes

	It is possible to include the source of another file into the current file by using preprocessor directives. This removes the need to   write code over and over again, as it can be stored in another file and reused at will. There are no headers, just source files. The     include directive takes the form of
     include <...> or include "..."


	Pointy brackets ('<' and '>') indicate that the file is a standard header, which is included with all compilers. Double quotes '"' indicate the file exists in a path relative to the path of the current file.

	When files are included, they are preprocessed recursively. The output of their respective preprocessing calls are inserted directly into the current file, after removing the include directive. Recursive includes must be detected by compilers, and should be avoided by using preprocessor conditionals. For example, say we have file "a.ws", the contents of which are

		include "b.ws"

		...

	and we have the file "b.ws", the contents of which are:
  ```c
	  int a = 1;
	  int b = 2;
      int c = 3;
  ```

	and the preprocessor is asked to preprocess "a.ws",

		1. The preprocessor begins scanning a.ws and encounters the include directive for "b.ws".
		2. The preprocessor attempts to locate "b.ws" relative to "a.ws"'s path, it succeeds.
		3. The preprocessor initializes another instance of itself, and asks it to preprocess "b.ws".
		4. The child preprocessor does not notice any preprocessor directives, and passes the file's content unchanged back to it's parent.
		5. The preprocessor replaces the include directive with the text generated by it's child preprocessor, the file now looks like this
	     
       int a = 1;
	   int b = 2;
       int c = 3;


			...

		6. The preprocessor continues to scan the file.

	3. Macros

	Macros can be defined using the 'define' keyword. The syntax of the define keyword is as follows
  ```c
	define <identifier> <...>
  ```
  
	The syntax consists of the define keyword followed by exactly one space and an identifier, followed by any string of text that occurs on one line.

	Whenever an occurrance of the defined identifier appears in following lines, that identifier is replaced by the exact copy of the text following the identifier in the preprocessor directive.

	4. Conditionals

	Conditionals may be implemented in a further revision of this language, but as of now there are no preprocessor conditionals provided.

	5. Escape Codes

	In string and character literals escape codes may be used. These escape codes must NOT be translated into their appropriate form by the preprocessor. The reason for this is that the escape codes which create a line break ('\n', etc.) can corrupt the flow of the program, as the entire language is based on indentation and line-feeds.

	Instead, escape codes should be processed by the lexer and converted into their appropriate form when generating a string or character token.

	6. Line Continuation

	Code that is too long to be legible on one line may be split into many lines by using the '\' token. You cannot split a line in the middle of a string or character literal. The following line should have proper indentation, but this is not required. Line continuation should be processed by the preprocessor before anything else, including macro replacement.

# Syntax

The syntax of the language is defined hereon. This includes the grammatical and semantic rules of the language, and the strict coding practises to be used while writing code in this language.

	1. Overview

		Seeing as this language is a indentation based language, the program flow can be different from one expects, this results is hard-to-find and annoying coding mistakes. However, this language is designed for the elite, and the elite only, so such mistakes are not uttered by the fingers of the elite. Thus, worthy users of this language need not worry about senseless and pleghm-brained mistakes.

		However, it is prudent to include examples of such mistakes, so that some of the lower-tier elite shall not have to embarrass themselves in front of masters of this language

		This programmer tried to count to one hundred and only swallow the even numbers. This was his code
    
   ```c
		1.	for int x = 0 while x < 100 doing x += 1
		2.		# Only swallow even numbers
		3.		if x % 2 == 0
		4.		swallow(x)
   ```

		He noticed that his code was swallowing 0, 1, 2, 3 ... all the way to 99. The reason for this is that on line 4, his swallow call is under line 1's indentation. Thus line 4 is inside line 1's closure, not line 3's. He should fix his code to include line 4 inside line 3's closure. His code will look like this
   ```c
		1.	for int x = 0 while x < 100 doing x += 1
		2.		# Only swallow even numbers
		3.		if x % 2 == 0
		4.			swallow(x)
  ```
		This code swallows 0, 2, 4, 6 ..., which is what the programmer wanted.

	b. Keywords

		There are quite a few keywords in this language. The keywords include

			byte		if 			include 	func
			short		else 		delete 		of
			int 		for 		inherits 	void
			long 		while 	 public
			float 		do 			private
			double 		doing 		auto
			number 		class 		type
			decimal 	define 		const

	c. Declarations

		A declaration in this language follows this syntax

			<type> <identifer>

		or, one could use the following syntax to initialize a value to the declared variable

			<type> <identifier> = <expression>

		The following criteria must be met when declaring a variable

			1. The type must have been declared previous to this declaration
			2. The identifier must not have been previously used in this variables full scope
			3. The identifier must be valid (see 2.i Identifiers)
			4. The expression used (if any) must be the same type as the type of the variable
			5. The identifier may not have been used previously as a function name

		If so, the variable can be declared. The variable can be deleted using the following syntax

			<delete> <identifier>

		The following criteria must be met when deleting a variable

			1. The identifier may not be a function name
			2. The identifier must have been previously declared
			3. The identifier may not have a constant type

	d. Assignments

		It is possible to assign a variable a value. The syntax of which is as follows

			<identifier> <assignment-operator> <expression>

		The following criteria must be met when declaring a variable

			1. Don't make me spell out what the identifier should and shouldn't be, you're not stupid.
			2. The expression must be the same type as the type of the identifier.

		The assignment operators that may be used are as follows

			Sequence		Function 		Description

			=				asgn(...)		Assign the right-hand operand to the left-hand operand
			+=				addasgn(...)	Add the right-hand operand to the left-hand operand
			-=				subasgn(...)	Subtract the right-hand operand from the left-hand operand
			*=				mulasgn(...)	Multiply right-hand operand by the left-hand operand
			/=				divasgn(...)	Divide the right-hand operand by the left-hand operand
			%=				modasgn(...)	Set the right-hand operand to (right-hand modulo left-hand)

		You can call any of the asgn functions like this

			<assignment-function>(<identifier>, <expression>)

		Don't try to make your own asgn or addasgn or something because it's impossible. These should be keywords but they are not because thats just stupid.

	e. Functions

		Functions look like this

			func <identifier>(<arg-type> <arg-identifier>, ...) of <return-type>
				...
				return <expression>

		You can omit the 'return <expression>' if your <return-type> is void.

		As of the current revision of this language, it is impossible to

			1. Define a function signature without actually coding the function body
			2. Delete a function
			3. Modify a function body programmatically

		It might be possible to do these things in later revisions of this language.

		Functions return a reference to the expression that was returned. Function arguments are references to the values passed, so modifying an argument modifies the value passed to the function as that argument as well, as they are literally the same object under different identifiers.

	f. Expressions

		Expressions are a wide topic. There are many literals that can be used as expressions

			String 			"string\n"

				String literals consist of a string of text surrounded by double quotes ('"'). These are of type byte[] usually, but some standard libraries may implement a string type.

			Character 		'\n'

				Character literals consist of one character or one escape code surrounded by single quotes ('''). These are of type byte.

			Integer			1, 2, +1, -2

				Integer literals consist of a number with an optional sign and no decimal point. If no sign is provided, is is assumed that the integer is positive. You may dictate the signed/unsigned part of the intger by following the literal with

					'U' or 'S' (capitalization matters)

				You may dictate the integer type that the literal is by following the literal with

					'l'		long
					'i'		int
					's'		short
					'b' 	byte

					Lowercase matters.

				Make sure that the signage follows the type specification if both are used, for example, to cast to an unsigned int, you should use

					14393iU

				not

					14393Ui

				If no type is specified, the type is inferred from the context of the literal.

			Decimal 		0.0, +0.0, -0.0

				Decimal literals are a number with an optional sign and an optional decimal point. You may dictate the type of the literal by following it with either of

					'd'		double or
					'f'		float

				There are no signed/unsigned doubles or floats. If no type is specified, the type is inferred from the context of the literal.

			Hexadecimal 	0xFFF, 0xfff, 0xFfF

				These are not yet implemented, but will be soon.

			Binary 			0b101010

				These are not yet implemented, but will be soon.

		You can use these literal types as expressions or combine them with other literals to make expressions. The operators that can be used in expressions are

			+	Addition
			-	Subtraction
			*	Multiplication
			/	Division
			%	Modulo

		You can also use the member access operator to access members of an object

			.	Member Access

		Identifiers can be used in expressions as well, and combined with literals. Literals are indeed objects themselves, as they are casted to an object before usage. To access members of a literal, use parentheses

			("dude")[0].getHashCode()

		Parentheses can be used to seperate expressions. When parentheses are not used, the BEDMAS/PEDMAS precedence table is used for numerical expressions. For non-numerical expressions, the expressions are evaluated left-to-right.
